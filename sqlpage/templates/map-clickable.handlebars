<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css">
<link rel="stylesheet" href="/style.css">

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<div id="{{#if id}}{{id}}{{else}}map{{/if}}"
    style="height: {{#if height}}{{height}}{{else}}600{{/if}}px;"></div>

<div style="margin:.5rem 0;">
  <button style="background-color:#3C2946;border:none;margin-right:auto;margin-left:auto;display:block;padding:10px;color:white;font-family:'Inter',sans-serif;font-weight:500;border-radius:10px;margin-bottom:-35px;"
          id="reset-map-btn" type="button">Reset Map</button>
</div>

<script nonce="{{@csp_nonce}}">
(function boot() {
  const el_id = "{{#if id}}{{id}}{{else}}map{{/if}}";
  const el = document.getElementById(el_id);
  if (!el) return;
  if (typeof window.L === 'undefined') return setTimeout(boot, 50);

  /* === JS PATCH: give tiles a tiny overlap to hide hairline seams === */
  (function patchLeafletTileOverlap() {
    if (!L || !L.GridLayer) return;
    const orig = L.GridLayer.prototype._initTile;
    if (orig && !orig.__overlapPatched) {
      L.GridLayer.prototype._initTile = function (tile) {
        orig.call(this, tile);
        const sz = this.getTileSize();
        tile.style.width  = (sz.x + 0.0) + 'px';
        tile.style.height = (sz.y + 0.0) + 'px';
      };
      L.GridLayer.prototype._initTile.__overlapPatched = true;
    }
  })();
  /* === end patch === */

  // --- Map init ---
  const init_lat  = {{#if latitude}}{{latitude}}{{else}}39.8283{{/if}};
  const init_lon  = {{#if longitude}}{{longitude}}{{else}}-98.5795{{/if}};
  const init_zoom = {{#if zoom}}{{zoom}}{{else}}4{{/if}};

  // World bounds in Web Mercator (avoid the polar singularities)
  const WORLD_BOUNDS = L.latLngBounds(L.latLng(-85, -180), L.latLng(85, 180));

  const map = L.map(el, {
    minZoom: 2,
    maxZoom: {{#if max_zoom}}{{max_zoom}}{{else}}19{{/if}},
    maxBounds: WORLD_BOUNDS,
    maxBoundsViscosity: 1.0,
    worldCopyJump: false,
    updateWhenZooming: false, // reduce tile churn during zoom animations (helps seams)
    // zoomSnap: 0,          // optional: allow fractional zooms
    zoomAnimation: false,
    fadeAnimation: false
  }).setView([init_lat, init_lon], init_zoom);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: {{#if max_zoom}}{{max_zoom}}{{else}}19{{/if}},
    tileSize: 256,          // OSM serves 256px tiles
    detectRetina: true,     // OK with OSM; set false if you prefer no @2x
    noWrap: true,           // single world – no horizontal repeat
    bounds: WORLD_BOUNDS,   // hint valid area
    keepBuffer: 3           // keep a few rings of tiles to avoid gaps while panning
  }).addTo(map);

  // --- Dataset selector (affects Baseline/Scenario values) ---
  let currentVariable = 'co2';
  const dsCtrl = L.control({ position: 'topright' });
  dsCtrl.onAdd = function() {
    const div = L.DomUtil.create('div', 'leaflet-bar');
    div.style.background = 'white';
    div.style.padding = '6px 8px';
    div.style.font = '14px/1.2 Inter, system-ui, sans-serif';
    div.innerHTML = `
      <div style="font-weight:600;margin-bottom:4px;">Dataset</div>
      <select id="dataset-select" style="width:180px;">
        <option value="co2">CAMS CO₂ (Air Quality)</option>
        <option value="precip">Agroclimatic Precipitation</option>
      </select>
    `;
    L.DomEvent.disableClickPropagation(div);
    return div;
  };
  dsCtrl.addTo(map);
  const dsSel = document.getElementById('dataset-select');
  if (dsSel) {
    currentVariable = dsSel.value;
    dsSel.addEventListener('change', () => { currentVariable = dsSel.value; });
  }

  // --- Helpers for value fetch & popup rendering ---
  async function fetchBaselineAt(lat, lon) {
    const url = `value_at.sql?variable=${encodeURIComponent(currentVariable)}&lat=${lat}&lon=${lon}`;
    const r = await fetch(url);
    const j = await r.json();
    return j.value || j;
  }

  async function fetchScenarioAt(lat, lon) {
    const url = `scenario_value_at.sql?variable=${encodeURIComponent(currentVariable)}&lat=${lat}&lon=${lon}`;
    const r = await fetch(url);
    const j = await r.json();
    return j.value || j;
  }

  function coordsHTML(lat, lon) {
    return `<div class="coords" style="margin-top:.25rem;font-size:.9em">
      <strong>Latitude:</strong> ${lat.toFixed(6)}<br>
      <strong>Longitude:</strong> ${lon.toFixed(6)}
    </div>`;
  }

  function renderPopupHTML(title, baseline, scenario, lat, lon) {
    return `
      <div style="min-width:220px">
        <div style="font-weight:600;margin-bottom:.25rem;">${title ?? 'Factory'}</div>
        <div><strong>Baseline (${currentVariable.toUpperCase()}):</strong> ${Number.isFinite(baseline)? baseline.toFixed(2) : '–'}</div>
        <div><strong>With Factories:</strong> ${Number.isFinite(scenario)? scenario.toFixed(2) : '–'}</div>
        ${coordsHTML(lat, lon)}
      </div>`;
  }

  async function refreshPopupForMarker(m, title) {
    const { lat, lng } = m.getLatLng();
    try {
      const [b, s] = await Promise.all([fetchBaselineAt(lat, lng), fetchScenarioAt(lat, lng)]);
      m.getPopup()?.setContent(renderPopupHTML(title, b.baseline, s.scenario, lat, lng));
    } catch {
      m.getPopup()?.setContent(renderPopupHTML(title, NaN, NaN, lat, lng));
    }
  }

  function wire_delete_on_popup_x(marker, marker_id) {
    marker.on('popupopen', (e) => {
      const popup_el = (e.popup.getElement && e.popup.getElement()) || e.popup._container;
      const close_button = popup_el && popup_el.querySelector('.leaflet-popup-close-button');
      if (!close_button) return;
      const on_close_click = (ev) => {
        ev.preventDefault();
        ev.stopPropagation();
        if (ev.stopImmediatePropagation) ev.stopImmediatePropagation();
        marker.remove();
        marker._deleted = true;
        if (marker_id != null) {
          fetch('delete_marker.sql', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: new URLSearchParams({ id: marker_id }).toString()
          });
        }
      };
      close_button.addEventListener('click', on_close_click, { once: true, capture: true });
    });
  }

  function attachDragPersist(marker, marker_id, title) {
    marker.on('dragend', () => {
      // 1) recompute values for new location
      refreshPopupForMarker(marker, title);
      // 2) persist new location if we have an id
      if (marker_id != null) {
        const { lat, lng } = marker.getLatLng();
        fetch('update_marker.sql', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({ id: marker_id, latitude: lat, longitude: lng }).toString()
        }).catch(()=>{});
      }
    });
  }

  // --- Render existing saved pins ---
  function add_saved_marker_from_feature(f, row_marker_id) {
    if (!f || f.type !== 'Feature' || !f.geometry || f.geometry.type !== 'Point') return;
    const [lon, lat] = f.geometry.coordinates || [];
    if (typeof lat !== 'number' || typeof lon !== 'number') return;

    const title = (f.properties && f.properties.title) || 'Factory';
    const m = L.marker([lat, lon], { draggable: true }).addTo(map);
    m.bindPopup('<div class="popup-body">Loading…</div>', { closeButton:true, closeOnClick:false, autoClose:false });

    // initial compute
    refreshPopupForMarker(m, title);
    wire_delete_on_popup_x(m, row_marker_id);
    attachDragPersist(m, row_marker_id, title);
    return m;
  }

  try {
    {{#each_row}}
      {{#if geojson}}
        (function() {
          try {
            const feature = {{{geojson}}};
            const row_marker_id = {{#if marker_id}}{{marker_id}}{{else}}null{{/if}};
            add_saved_marker_from_feature(feature, row_marker_id);
          } catch (e) { console.error('Bad GeoJSON row', e); }
        })();
      {{/if}}
    {{/each_row}}
  } catch (e) {
    console.error('Rendering existing markers failed', e);
  }

  // --- Click to add new factory ---
  map.on('click', (e) => {
    const { lat, lng } = e.latlng;
    const m = L.marker([lat, lng], { draggable: true }).addTo(map);
    m.bindPopup(`<div class="popup-body">Saving…</div>${coordsHTML(lat, lng)}`, { closeButton:true, closeOnClick:false, autoClose:false }).openPopup();

    wire_delete_on_popup_x(m, null);

    // Save to DB and then compute values
    fetch('add_marker.sql', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({ latitude: lat, longitude: lng, title: '' }).toString()
    })
    .then(r => r.text())
    .then(t => {
      const match = t && t.match(/(\d+)/);
      const new_id = match ? parseInt(match[1], 10) : null;

      if (m._deleted) {
        if (new_id != null) {
          fetch('delete_marker.sql', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: new URLSearchParams({ id: new_id }).toString()
          });
        }
        return;
      }

      // compute values for current location
      refreshPopupForMarker(m, 'Factory');

      // rewire delete with id & enable DB persist on drag
      wire_delete_on_popup_x(m, new_id);
      attachDragPersist(m, new_id, 'Factory');
    })
    .catch(() => {
      m.getPopup()?.setContent(renderPopupHTML('Factory', NaN, NaN, lat, lng));
    });
  });

  // --- Reset all markers (DB) then refresh page ---
  document.getElementById('reset-map-btn')?.addEventListener('click', () => {
    fetch('clear_markers.sql', { method: 'POST' })
      .then(() => location.reload())
      .catch(() => location.reload());
  });
})();
</script>