<div id="{{#if id}}{{id}}{{else}}map{{/if}}"
     style="height: {{#if height}}{{height}}{{else}}600{{/if}}px;"></div>

<div style="margin:.5rem 0;">
  <button style="background-color:#3C2946;border:none;margin-right:auto;margin-left:auto;display:block;padding:10px;color:white;font-family:'Inter',sans-serif;font-weight:500;border-radius:10px;margin-bottom:-35px;"
          id="reset-map-btn" type="button">Reset Map</button>
</div>

<script nonce="{{@csp_nonce}}">
(function boot() {
  const el_id = "{{#if id}}{{id}}{{else}}map{{/if}}";
  const el = document.getElementById(el_id);
  if (!el) return;
  if (typeof window.L === 'undefined') return setTimeout(boot, 50);

  /* ===== Hardcoded fallback for baseline COâ‚‚ (ppm) ===== */
  const HARDCODED_CO2_BASELINE = 420;  // ðŸ‘ˆ change this value as needed

  /* (optional) tiny tile-seam patch â€“ disabled (0px) */
  (function patchLeafletTileOverlap() {
    if (!L || !L.GridLayer) return;
    const orig = L.GridLayer.prototype._initTile;
    if (orig && !orig.__overlapPatched) {
      L.GridLayer.prototype._initTile = function (tile) {
        orig.call(this, tile);
        const sz = this.getTileSize();
        tile.style.width  = (sz.x + 0.0) + 'px';
        tile.style.height = (sz.y + 0.0) + 'px';
      };
      L.GridLayer.prototype._initTile.__overlapPatched = true;
    }
  })();

  // --- Map init ---
  const init_lat  = {{#if latitude}}{{latitude}}{{else}}39.8283{{/if}};
  const init_lon  = {{#if longitude}}{{longitude}}{{else}}-98.5795{{/if}};
  const init_zoom = {{#if zoom}}{{zoom}}{{else}}4{{/if}};
  const WORLD_BOUNDS = L.latLngBounds(L.latLng(-85, -180), L.latLng(85, 180));

  const map = L.map(el, {
    minZoom: 2,
    maxZoom: {{#if max_zoom}}{{max_zoom}}{{else}}19{{/if}},
    maxBounds: WORLD_BOUNDS,
    maxBoundsViscosity: 1.0,
    worldCopyJump: false,
    zoomAnimation: true,
    fadeAnimation: true,
    zoomSnap: 0,
    wheelDebounceTime: 20,
    wheelPxPerZoomLevel: 10
  }).setView([init_lat, init_lon], init_zoom);

  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: {{#if max_zoom}}{{max_zoom}}{{else}}19{{/if}},
    tileSize: 256,
    detectRetina: true,
    noWrap: true,
    bounds: WORLD_BOUNDS,
    updateWhenZooming: true,
    updateWhenIdle: false,
    keepBuffer: 4
  }).addTo(map);

  // ===== Dataset control (kept minimal) =====
  let currentVariable = 'co2';
  const dsCtrl = L.control({ position: 'topright' });
  dsCtrl.onAdd = function() {
    const div = L.DomUtil.create('div', 'leaflet-bar');
    div.style.background = 'white';
    div.style.padding = '6px 8px';
    div.style.font = '14px/1.2 Inter, system-ui, sans-serif';
    div.style.minWidth = '220px';
    div.innerHTML = `
      <div style="font-weight:600;margin-bottom:4px;">Dataset</div>
      <select id="dataset-select" style="width:200px;">
        <option value="co2" selected>COâ‚‚ (Air Quality)</option>
        <option value="precip">Agroclimatic Precipitation</option>
      </select>
    `;
    L.DomEvent.disableClickPropagation(div);
    return div;
  };
  dsCtrl.addTo(map);

  const dsSel = document.getElementById('dataset-select');
  if (dsSel) {
    currentVariable = dsSel.value;
    dsSel.addEventListener('change', () => {
      currentVariable = dsSel.value;
      scheduleCountryPaint?.();   // ok if overlay code not present
    });
  }

  // ===== Value endpoints =====
  async function fetchBaselineAt(lat, lon) {
    const url = `value_at.sql?variable=${encodeURIComponent(currentVariable)}&lat=${lat}&lon=${lon}`;
    try {
      const r = await fetch(url, { headers: { 'Accept': 'application/json' }});
      const j = await r.json();
      const o = (j && j.contents && typeof j.contents === 'object') ? j.contents : j;
      // Hardcoded fallback only affects BASELINE in UI when missing
      const val = Number.isFinite(o?.baseline) ? o.baseline : HARDCODED_CO2_BASELINE;
      return { baseline: val };
    } catch {
      return { baseline: HARDCODED_CO2_BASELINE };
    }
  }

  async function fetchScenarioAt(lat, lon) {
    const url = `scenario_value_at.sql?variable=${encodeURIComponent(currentVariable)}&lat=${lat}&lon=${lon}`;
    try {
      const r = await fetch(url, { headers: { 'Accept': 'application/json' }});
      const j = await r.json();
      const o = (j && j.contents && typeof j.contents === 'object') ? j.contents : j;
      return o; // { scenario: number | null }
    } catch {
      return { scenario: null }; // unchanged; only baseline is forced
    }
  }

  // ===== Popups / markers =====
  function coordsHTML(lat, lon) {
    return `<div class="coords" style="margin-top:.25rem;font-size:.9em">
      <strong>Latitude:</strong> ${lat.toFixed(6)}<br>
      <strong>Longitude:</strong> ${lon.toFixed(6)}
    </div>`;
  }

  function renderPopupHTML(title, baseline, scenario, lat, lon) {
    // Baseline is already guaranteed numeric via fetchBaselineAt()
    return `
      <div style="min-width:240px">
        <div style="font-weight:600;margin-bottom:.25rem;">${title ?? 'Factory'}</div>
        <div><strong>Baseline (${currentVariable.toUpperCase()}):</strong> ${baseline.toFixed(2)}</div>
        <div><strong>With Factories:</strong> ${Number.isFinite(scenario)? scenario.toFixed(2) : 'â€“'}</div>
        ${coordsHTML(lat, lon)}
      </div>`;
  }

  async function refreshPopupForMarker(m, title) {
    const { lat, lng } = m.getLatLng();
    try {
      const [b, s] = await Promise.all([fetchBaselineAt(lat, lng), fetchScenarioAt(lat, lng)]);
      m.getPopup()?.setContent(renderPopupHTML(title, b.baseline, s.scenario, lat, lng));
    } catch {
      // If even the fetch fails, show the hardcoded baseline
      m.getPopup()?.setContent(renderPopupHTML(title, HARDCODED_CO2_BASELINE, NaN, lat, lng));
    }
  }

  function wire_delete_on_popup_x(marker, marker_id) {
    marker.on('popupopen', (e) => {
      const popup_el = (e.popup.getElement && e.popup.getElement()) || e.popup._container;
      const close_button = popup_el && popup_el.querySelector('.leaflet-popup-close-button');
      if (!close_button) return;
      const on_close_click = (ev) => {
        ev.preventDefault(); ev.stopPropagation();
        if (ev.stopImmediatePropagation) ev.stopImmediatePropagation();
        marker.remove();
        marker._deleted = true;
        if (marker_id != null) {
          fetch('delete_marker.sql', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: new URLSearchParams({ id: marker_id }).toString()
          });
        }
      };
      close_button.addEventListener('click', on_close_click, { once: true, capture: true });
    });
  }

  function attachDragPersist(marker, marker_id, title) {
    marker.on('dragend', () => {
      refreshPopupForMarker(marker, title);
      if (marker_id != null) {
        const { lat, lng } = marker.getLatLng();
        fetch('update_marker.sql', {
          method: 'POST',
          headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
          body: new URLSearchParams({ id: marker_id, latitude: lat, longitude: lng }).toString()
        }).catch(()=>{});
      }
    });
  }

  // --- Render existing saved pins (if provided) ---
  function add_saved_marker_from_feature(f, row_marker_id) {
    if (!f || f.type !== 'Feature' || !f.geometry || f.geometry.type !== 'Point') return;
    const [lon, lat] = f.geometry.coordinates || [];
    if (typeof lat !== 'number' || typeof lon !== 'number') return;

    const title = (f.properties && f.properties.title) || 'Factory';
    const m = L.marker([lat, lon], { draggable: true }).addTo(map);
    m.bindPopup('<div class="popup-body">Loadingâ€¦</div>', {
      closeButton:true, closeOnClick:false, autoClose:false
    });

    refreshPopupForMarker(m, title);
    wire_delete_on_popup_x(m, row_marker_id);
    attachDragPersist(m, row_marker_id, title);
    return m;
  }

  try {
    {{#each_row}}
      {{#if geojson}}
        (function() {
          try {
            const feature = {{{geojson}}};
            const row_marker_id = {{#if marker_id}}{{marker_id}}{{else}}null{{/if}};
            add_saved_marker_from_feature(feature, row_marker_id);
          } catch (e) { console.error('Bad GeoJSON row', e); }
        })();
      {{/if}}
    {{/each_row}}
  } catch (e) {
    console.error('Rendering existing markers failed', e);
  }

  // --- Click to add new pin ---
  map.on('click', (e) => {
    const { lat, lng } = e.latlng;
    const m = L.marker([lat, lng], { draggable: true }).addTo(map);
    m.bindPopup(`<div class="popup-body">Savingâ€¦</div>${coordsHTML(lat, lng)}`, {
      closeButton:true, closeOnClick:false, autoClose:false
    }).openPopup();

    wire_delete_on_popup_x(m, null);

    // Save to DB; then compute values
    fetch('add_marker.sql', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({ latitude: lat, longitude: lng, title: '' }).toString()
    })
    .then(r => r.text())
    .then(t => {
      const match = t && t.match(/(\d+)/);
      const new_id = match ? parseInt(match[1], 10) : null;

      if (m._deleted) {
        if (new_id != null) {
          fetch('delete_marker.sql', {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body: new URLSearchParams({ id: new_id }).toString()
          });
        }
        return;
      }

      refreshPopupForMarker(m, 'Factory');
      wire_delete_on_popup_x(m, new_id);
      attachDragPersist(m, new_id, 'Factory');
    })
    .catch(() => {
      m.getPopup()?.setContent(renderPopupHTML('Factory', HARDCODED_CO2_BASELINE, NaN, lat, lng));
    });
  });

  // --- Reset all markers (DB) then refresh page ---
  document.getElementById('reset-map-btn')?.addEventListener('click', () => {
    fetch('clear_markers.sql', { method: 'POST' })
      .then(() => location.reload())
      .catch(() => location.reload());
  });

  // === (Optional) Country COâ‚‚ choropleth code can stay below, unchanged ===
  // If you already added that section earlier, you can keep it; it wonâ€™t be affected by this popup change.
})();
</script>